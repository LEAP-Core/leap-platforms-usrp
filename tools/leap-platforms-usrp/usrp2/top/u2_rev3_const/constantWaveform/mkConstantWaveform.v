//
// Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
//
// On Tue Jan 10 20:04:11 EST 2012
//
// Method conflict info:
// Method: data_get
// Conflict-free: token_get
// Conflicts: data_get
//
// Method: token_get
// Conflict-free: data_get
// Conflicts: token_get
//
//
// Ports:
// Name                         I/O  size props
// data_get                       O    32 reg
// RDY_data_get                   O     1 reg
// token_get                      O     1 reg
// RDY_token_get                  O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// EN_data_get                    I     1
// EN_token_get                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkConstantWaveform(CLK,
			  RST_N,

			  EN_data_get,
			  data_get,
			  RDY_data_get,

			  EN_token_get,
			  token_get,
			  RDY_token_get);
  input  CLK;
  input  RST_N;

  // actionvalue method data_get
  input  EN_data_get;
  output [31 : 0] data_get;
  output RDY_data_get;

  // actionvalue method token_get
  input  EN_token_get;
  output token_get;
  output RDY_token_get;

  // signals for module outputs
  wire [31 : 0] data_get;
  wire RDY_data_get, RDY_token_get, token_get;

  // register counter
  reg [15 : 0] counter;
  wire [15 : 0] counter$D_IN;
  wire counter$EN;

  // ports of submodule dataFIFO
  wire [31 : 0] dataFIFO$D_IN, dataFIFO$D_OUT;
  wire dataFIFO$CLR,
       dataFIFO$DEQ,
       dataFIFO$EMPTY_N,
       dataFIFO$ENQ,
       dataFIFO$FULL_N;

  // ports of submodule tokenFIFO
  wire tokenFIFO$CLR,
       tokenFIFO$DEQ,
       tokenFIFO$D_IN,
       tokenFIFO$D_OUT,
       tokenFIFO$EMPTY_N,
       tokenFIFO$ENQ,
       tokenFIFO$FULL_N;

  // ports of submodule waveform
  wire [31 : 0] waveform$readRsp;
  wire [9 : 0] waveform$readReq_addr;
  wire waveform$EN_readReq;

  // rule scheduling signals
  wire WILL_FIRE_RL_count;

  // remaining internal signals
  wire counter_MINUS_1_1_ULT_722___d12;

  // actionvalue method data_get
  assign data_get = dataFIFO$D_OUT ;
  assign RDY_data_get = dataFIFO$EMPTY_N ;

  // actionvalue method token_get
  assign token_get = tokenFIFO$D_OUT ;
  assign RDY_token_get = tokenFIFO$EMPTY_N ;

  // submodule dataFIFO
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) dataFIFO(.RST_N(RST_N),
					.CLK(CLK),
					.D_IN(dataFIFO$D_IN),
					.ENQ(dataFIFO$ENQ),
					.DEQ(dataFIFO$DEQ),
					.CLR(dataFIFO$CLR),
					.D_OUT(dataFIFO$D_OUT),
					.FULL_N(dataFIFO$FULL_N),
					.EMPTY_N(dataFIFO$EMPTY_N));

  // submodule tokenFIFO
  SizedFIFO #(.p1width(32'd1),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) tokenFIFO(.RST_N(RST_N),
					 .CLK(CLK),
					 .D_IN(tokenFIFO$D_IN),
					 .ENQ(tokenFIFO$ENQ),
					 .DEQ(tokenFIFO$DEQ),
					 .CLR(tokenFIFO$CLR),
					 .D_OUT(tokenFIFO$D_OUT),
					 .FULL_N(tokenFIFO$FULL_N),
					 .EMPTY_N(tokenFIFO$EMPTY_N));

  // submodule waveform
  mkBRAMWaveform waveform(.CLK(CLK),
			  .RST_N(RST_N),
			  .readReq_addr(waveform$readReq_addr),
			  .EN_readReq(waveform$EN_readReq),
			  .RDY_readReq(),
			  .readRsp(waveform$readRsp),
			  .RDY_readRsp());

  // rule RL_count
  assign WILL_FIRE_RL_count = dataFIFO$FULL_N && tokenFIFO$FULL_N ;

  // register counter
  assign counter$D_IN = counter + 16'd1 ;
  assign counter$EN = WILL_FIRE_RL_count ;

  // submodule dataFIFO
  assign dataFIFO$D_IN = waveform$readRsp ;
  assign dataFIFO$ENQ =
	     WILL_FIRE_RL_count && counter_MINUS_1_1_ULT_722___d12 ;
  assign dataFIFO$DEQ = EN_data_get ;
  assign dataFIFO$CLR = 1'b0 ;

  // submodule tokenFIFO
  assign tokenFIFO$D_IN = counter == 16'd722 ;
  assign tokenFIFO$ENQ =
	     WILL_FIRE_RL_count && counter_MINUS_1_1_ULT_722___d12 ;
  assign tokenFIFO$DEQ = EN_token_get ;
  assign tokenFIFO$CLR = 1'b0 ;

  // submodule waveform
  assign waveform$readReq_addr = counter[9:0] ;
  assign waveform$EN_readReq = WILL_FIRE_RL_count ;

  // remaining internal signals
  assign counter_MINUS_1_1_ULT_722___d12 = counter - 16'd1 < 16'd722 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        counter <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counter = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkConstantWaveform

