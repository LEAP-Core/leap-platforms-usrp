//
// Generated by Bluespec Compiler, version 2011.06.D (build 24470, 2011-06-30)
//
// On Sun Jan 15 07:18:51 EST 2012
//
// Method conflict info:
// Method: data_get
// Conflict-free: token_get
// Conflicts: data_get
//
// Method: token_get
// Conflict-free: data_get
// Conflicts: token_get
//
//
// Ports:
// Name                         I/O  size props
// data_get                       O    32 reg
// RDY_data_get                   O     1 reg
// token_get                      O     1 reg
// RDY_token_get                  O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// EN_data_get                    I     1
// EN_token_get                   I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkConstantWaveform(CLK,
			  RST_N,

			  EN_data_get,
			  data_get,
			  RDY_data_get,

			  EN_token_get,
			  token_get,
			  RDY_token_get);
  input  CLK;
  input  RST_N;

  // actionvalue method data_get
  input  EN_data_get;
  output [31 : 0] data_get;
  output RDY_data_get;

  // actionvalue method token_get
  input  EN_token_get;
  output token_get;
  output RDY_token_get;

  // signals for module outputs
  wire [31 : 0] data_get;
  wire RDY_data_get, RDY_token_get, token_get;

  // register counter
  reg [15 : 0] counter;
  wire [15 : 0] counter$D_IN;
  wire counter$EN;

  // ports of submodule dataFIFO
  wire [31 : 0] dataFIFO$D_IN, dataFIFO$D_OUT;
  wire dataFIFO$CLR,
       dataFIFO$DEQ,
       dataFIFO$EMPTY_N,
       dataFIFO$ENQ,
       dataFIFO$FULL_N;

  // ports of submodule scaleDataFIFO
  wire [31 : 0] scaleDataFIFO$D_IN, scaleDataFIFO$D_OUT;
  wire scaleDataFIFO$CLR,
       scaleDataFIFO$DEQ,
       scaleDataFIFO$EMPTY_N,
       scaleDataFIFO$ENQ,
       scaleDataFIFO$FULL_N;

  // ports of submodule scaleDataFIFO2
  wire [31 : 0] scaleDataFIFO2$D_IN, scaleDataFIFO2$D_OUT;
  wire scaleDataFIFO2$CLR,
       scaleDataFIFO2$DEQ,
       scaleDataFIFO2$EMPTY_N,
       scaleDataFIFO2$ENQ,
       scaleDataFIFO2$FULL_N;

  // ports of submodule tokenFIFO
  wire tokenFIFO$CLR,
       tokenFIFO$DEQ,
       tokenFIFO$D_IN,
       tokenFIFO$D_OUT,
       tokenFIFO$EMPTY_N,
       tokenFIFO$ENQ,
       tokenFIFO$FULL_N;

  // ports of submodule waveform
  wire [31 : 0] waveform$readRsp;
  wire [9 : 0] waveform$readReq_addr;
  wire waveform$EN_readReq;

  // rule scheduling signals
  wire WILL_FIRE_RL_count;

  // remaining internal signals
  wire [63 : 0] _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0_5_6___d27,
		_14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC___d21;
  wire [31 : 0] SEXT__14745_MUL_SEXT_dataFIFO_first__8_BITS_15_ETC__q8,
		SEXT__14745_MUL_SEXT_dataFIFO_first__8_BITS_31_ETC__q5,
		_14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0__ETC__q6,
		_14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC__q3;
  wire [17 : 0] _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0__ETC__q7,
		_14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC__q4;
  wire [15 : 0] dataFIFOD_OUT_BITS_15_TO_0__q2,
		dataFIFOD_OUT_BITS_31_TO_16__q1;
  wire counter_MINUS_1_1_ULT_722___d12;

  // actionvalue method data_get
  assign data_get = scaleDataFIFO2$D_OUT ;
  assign RDY_data_get = scaleDataFIFO2$EMPTY_N ;

  // actionvalue method token_get
  assign token_get = tokenFIFO$D_OUT ;
  assign RDY_token_get = tokenFIFO$EMPTY_N ;

  // submodule dataFIFO
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) dataFIFO(.RST_N(RST_N),
					.CLK(CLK),
					.D_IN(dataFIFO$D_IN),
					.ENQ(dataFIFO$ENQ),
					.DEQ(dataFIFO$DEQ),
					.CLR(dataFIFO$CLR),
					.D_OUT(dataFIFO$D_OUT),
					.FULL_N(dataFIFO$FULL_N),
					.EMPTY_N(dataFIFO$EMPTY_N));

  // submodule scaleDataFIFO
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) scaleDataFIFO(.RST_N(RST_N),
					     .CLK(CLK),
					     .D_IN(scaleDataFIFO$D_IN),
					     .ENQ(scaleDataFIFO$ENQ),
					     .DEQ(scaleDataFIFO$DEQ),
					     .CLR(scaleDataFIFO$CLR),
					     .D_OUT(scaleDataFIFO$D_OUT),
					     .FULL_N(scaleDataFIFO$FULL_N),
					     .EMPTY_N(scaleDataFIFO$EMPTY_N));

  // submodule scaleDataFIFO2
  SizedFIFO #(.p1width(32'd32),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) scaleDataFIFO2(.RST_N(RST_N),
					      .CLK(CLK),
					      .D_IN(scaleDataFIFO2$D_IN),
					      .ENQ(scaleDataFIFO2$ENQ),
					      .DEQ(scaleDataFIFO2$DEQ),
					      .CLR(scaleDataFIFO2$CLR),
					      .D_OUT(scaleDataFIFO2$D_OUT),
					      .FULL_N(scaleDataFIFO2$FULL_N),
					      .EMPTY_N(scaleDataFIFO2$EMPTY_N));

  // submodule tokenFIFO
  SizedFIFO #(.p1width(32'd1),
	      .p2depth(32'd4),
	      .p3cntr_width(32'd2),
	      .guarded(32'd1)) tokenFIFO(.RST_N(RST_N),
					 .CLK(CLK),
					 .D_IN(tokenFIFO$D_IN),
					 .ENQ(tokenFIFO$ENQ),
					 .DEQ(tokenFIFO$DEQ),
					 .CLR(tokenFIFO$CLR),
					 .D_OUT(tokenFIFO$D_OUT),
					 .FULL_N(tokenFIFO$FULL_N),
					 .EMPTY_N(tokenFIFO$EMPTY_N));

  // submodule waveform
  mkBRAMWaveform waveform(.CLK(CLK),
			  .RST_N(RST_N),
			  .readReq_addr(waveform$readReq_addr),
			  .EN_readReq(waveform$EN_readReq),
			  .RDY_readReq(),
			  .readRsp(waveform$readRsp),
			  .RDY_readRsp());

  // rule RL_count
  assign WILL_FIRE_RL_count = dataFIFO$FULL_N && tokenFIFO$FULL_N ;

  // register counter
  assign counter$D_IN = counter + 16'd1 ;
  assign counter$EN = WILL_FIRE_RL_count ;

  // submodule dataFIFO
  assign dataFIFO$D_IN = waveform$readRsp ;
  assign dataFIFO$ENQ =
	     WILL_FIRE_RL_count && counter_MINUS_1_1_ULT_722___d12 ;
  assign dataFIFO$DEQ = dataFIFO$EMPTY_N && scaleDataFIFO$FULL_N ;
  assign dataFIFO$CLR = 1'b0 ;

  // submodule scaleDataFIFO
  assign scaleDataFIFO$D_IN =
	     { SEXT__14745_MUL_SEXT_dataFIFO_first__8_BITS_31_ETC__q5[15:0],
	       SEXT__14745_MUL_SEXT_dataFIFO_first__8_BITS_15_ETC__q8[15:0] } ;
  assign scaleDataFIFO$ENQ = dataFIFO$EMPTY_N && scaleDataFIFO$FULL_N ;
  assign scaleDataFIFO$DEQ = scaleDataFIFO$EMPTY_N && scaleDataFIFO2$FULL_N ;
  assign scaleDataFIFO$CLR = 1'b0 ;

  // submodule scaleDataFIFO2
  assign scaleDataFIFO2$D_IN = scaleDataFIFO$D_OUT ;
  assign scaleDataFIFO2$ENQ = scaleDataFIFO$EMPTY_N && scaleDataFIFO2$FULL_N ;
  assign scaleDataFIFO2$DEQ = EN_data_get ;
  assign scaleDataFIFO2$CLR = 1'b0 ;

  // submodule tokenFIFO
  assign tokenFIFO$D_IN = counter == 16'd722 ;
  assign tokenFIFO$ENQ =
	     WILL_FIRE_RL_count && counter_MINUS_1_1_ULT_722___d12 ;
  assign tokenFIFO$DEQ = EN_token_get ;
  assign tokenFIFO$CLR = 1'b0 ;

  // submodule waveform
  assign waveform$readReq_addr = counter[9:0] ;
  assign waveform$EN_readReq = WILL_FIRE_RL_count ;

  // remaining internal signals
  assign SEXT__14745_MUL_SEXT_dataFIFO_first__8_BITS_15_ETC__q8 =
	     { {14{_14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0__ETC__q7[17]}},
	       _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0__ETC__q7 } ;
  assign SEXT__14745_MUL_SEXT_dataFIFO_first__8_BITS_31_ETC__q5 =
	     { {14{_14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC__q4[17]}},
	       _14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC__q4 } ;
  assign _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0_5_6___d27 =
	     32'd14745 *
	     { {16{dataFIFOD_OUT_BITS_15_TO_0__q2[15]}},
	       dataFIFOD_OUT_BITS_15_TO_0__q2 } ;
  assign _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0__ETC__q6 =
	     _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0_5_6___d27[31:0] ;
  assign _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0__ETC__q7 =
	     _14745_MUL_SEXT_dataFIFO_first__8_BITS_15_TO_0__ETC__q6[31:14] ;
  assign _14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC___d21 =
	     32'd14745 *
	     { {16{dataFIFOD_OUT_BITS_31_TO_16__q1[15]}},
	       dataFIFOD_OUT_BITS_31_TO_16__q1 } ;
  assign _14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC__q3 =
	     _14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC___d21[31:0] ;
  assign _14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC__q4 =
	     _14745_MUL_SEXT_dataFIFO_first__8_BITS_31_TO_16_ETC__q3[31:14] ;
  assign counter_MINUS_1_1_ULT_722___d12 = counter - 16'd1 < 16'd722 ;
  assign dataFIFOD_OUT_BITS_15_TO_0__q2 = dataFIFO$D_OUT[15:0] ;
  assign dataFIFOD_OUT_BITS_31_TO_16__q1 = dataFIFO$D_OUT[31:16] ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        counter <= `BSV_ASSIGNMENT_DELAY 16'd0;
      end
    else
      begin
        if (counter$EN) counter <= `BSV_ASSIGNMENT_DELAY counter$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    counter = 16'hAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkConstantWaveform

