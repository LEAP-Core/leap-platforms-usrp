
/***********************************************************************
 * This file was generated by gen_convert_general.py on Sat Apr  2 14:36:29 2011
 **********************************************************************/

#include "convert_common.hpp"
#include <uhd/utils/byteswap.hpp>

using namespace uhd::convert;

DECLARE_CONVERTER(convert_fc64_1_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc64_t *input = reinterpret_cast<const fc64_t *>(inputs[0]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = (fc64_to_item32(input[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_1_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output = reinterpret_cast<fc64_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = item32_to_fc64((input[i]));
    }
}

DECLARE_CONVERTER(convert_fc32_1_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc32_t *input = reinterpret_cast<const fc32_t *>(inputs[0]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = (fc32_to_item32(input[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_1_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output = reinterpret_cast<fc32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = item32_to_fc32((input[i]));
    }
}

DECLARE_CONVERTER(convert_sc16_1_to_item32_1_nswap, PRIORITY_GENERAL){
    const sc16_t *input = reinterpret_cast<const sc16_t *>(inputs[0]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = (sc16_to_item32(input[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_1_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output = reinterpret_cast<sc16_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = item32_to_sc16((input[i]));
    }
}

DECLARE_CONVERTER(convert_fc64_1_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc64_t *input = reinterpret_cast<const fc64_t *>(inputs[0]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = uhd::byteswap(fc64_to_item32(input[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_1_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output = reinterpret_cast<fc64_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = item32_to_fc64(uhd::byteswap(input[i]));
    }
}

DECLARE_CONVERTER(convert_fc32_1_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc32_t *input = reinterpret_cast<const fc32_t *>(inputs[0]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = uhd::byteswap(fc32_to_item32(input[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_1_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output = reinterpret_cast<fc32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = item32_to_fc32(uhd::byteswap(input[i]));
    }
}

DECLARE_CONVERTER(convert_sc16_1_to_item32_1_bswap, PRIORITY_GENERAL){
    const sc16_t *input = reinterpret_cast<const sc16_t *>(inputs[0]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = uhd::byteswap(sc16_to_item32(input[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_1_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output = reinterpret_cast<sc16_t *>(outputs[0]);

    for (size_t i = 0; i < nsamps; i++){
        output[i] = item32_to_sc16(uhd::byteswap(input[i]));
    }
}

DECLARE_CONVERTER(convert_fc64_2_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc64_t *input0 = reinterpret_cast<const fc64_t *>(inputs[0]);
    const fc64_t *input1 = reinterpret_cast<const fc64_t *>(inputs[1]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (fc64_to_item32(input0[i]));
        output[j++] = (fc64_to_item32(input1[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_2_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output0 = reinterpret_cast<fc64_t *>(outputs[0]);
    fc64_t *output1 = reinterpret_cast<fc64_t *>(outputs[1]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc64((input[j++]));
        output1[i] = item32_to_fc64((input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc32_2_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc32_t *input0 = reinterpret_cast<const fc32_t *>(inputs[0]);
    const fc32_t *input1 = reinterpret_cast<const fc32_t *>(inputs[1]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (fc32_to_item32(input0[i]));
        output[j++] = (fc32_to_item32(input1[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_2_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output0 = reinterpret_cast<fc32_t *>(outputs[0]);
    fc32_t *output1 = reinterpret_cast<fc32_t *>(outputs[1]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc32((input[j++]));
        output1[i] = item32_to_fc32((input[j++]));
    }
}

DECLARE_CONVERTER(convert_sc16_2_to_item32_1_nswap, PRIORITY_GENERAL){
    const sc16_t *input0 = reinterpret_cast<const sc16_t *>(inputs[0]);
    const sc16_t *input1 = reinterpret_cast<const sc16_t *>(inputs[1]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (sc16_to_item32(input0[i]));
        output[j++] = (sc16_to_item32(input1[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_2_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output0 = reinterpret_cast<sc16_t *>(outputs[0]);
    sc16_t *output1 = reinterpret_cast<sc16_t *>(outputs[1]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_sc16((input[j++]));
        output1[i] = item32_to_sc16((input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc64_2_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc64_t *input0 = reinterpret_cast<const fc64_t *>(inputs[0]);
    const fc64_t *input1 = reinterpret_cast<const fc64_t *>(inputs[1]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(fc64_to_item32(input0[i]));
        output[j++] = uhd::byteswap(fc64_to_item32(input1[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_2_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output0 = reinterpret_cast<fc64_t *>(outputs[0]);
    fc64_t *output1 = reinterpret_cast<fc64_t *>(outputs[1]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc64(uhd::byteswap(input[j++]));
        output1[i] = item32_to_fc64(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc32_2_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc32_t *input0 = reinterpret_cast<const fc32_t *>(inputs[0]);
    const fc32_t *input1 = reinterpret_cast<const fc32_t *>(inputs[1]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(fc32_to_item32(input0[i]));
        output[j++] = uhd::byteswap(fc32_to_item32(input1[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_2_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output0 = reinterpret_cast<fc32_t *>(outputs[0]);
    fc32_t *output1 = reinterpret_cast<fc32_t *>(outputs[1]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc32(uhd::byteswap(input[j++]));
        output1[i] = item32_to_fc32(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_sc16_2_to_item32_1_bswap, PRIORITY_GENERAL){
    const sc16_t *input0 = reinterpret_cast<const sc16_t *>(inputs[0]);
    const sc16_t *input1 = reinterpret_cast<const sc16_t *>(inputs[1]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(sc16_to_item32(input0[i]));
        output[j++] = uhd::byteswap(sc16_to_item32(input1[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_2_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output0 = reinterpret_cast<sc16_t *>(outputs[0]);
    sc16_t *output1 = reinterpret_cast<sc16_t *>(outputs[1]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_sc16(uhd::byteswap(input[j++]));
        output1[i] = item32_to_sc16(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc64_3_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc64_t *input0 = reinterpret_cast<const fc64_t *>(inputs[0]);
    const fc64_t *input1 = reinterpret_cast<const fc64_t *>(inputs[1]);
    const fc64_t *input2 = reinterpret_cast<const fc64_t *>(inputs[2]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (fc64_to_item32(input0[i]));
        output[j++] = (fc64_to_item32(input1[i]));
        output[j++] = (fc64_to_item32(input2[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_3_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output0 = reinterpret_cast<fc64_t *>(outputs[0]);
    fc64_t *output1 = reinterpret_cast<fc64_t *>(outputs[1]);
    fc64_t *output2 = reinterpret_cast<fc64_t *>(outputs[2]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc64((input[j++]));
        output1[i] = item32_to_fc64((input[j++]));
        output2[i] = item32_to_fc64((input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc32_3_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc32_t *input0 = reinterpret_cast<const fc32_t *>(inputs[0]);
    const fc32_t *input1 = reinterpret_cast<const fc32_t *>(inputs[1]);
    const fc32_t *input2 = reinterpret_cast<const fc32_t *>(inputs[2]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (fc32_to_item32(input0[i]));
        output[j++] = (fc32_to_item32(input1[i]));
        output[j++] = (fc32_to_item32(input2[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_3_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output0 = reinterpret_cast<fc32_t *>(outputs[0]);
    fc32_t *output1 = reinterpret_cast<fc32_t *>(outputs[1]);
    fc32_t *output2 = reinterpret_cast<fc32_t *>(outputs[2]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc32((input[j++]));
        output1[i] = item32_to_fc32((input[j++]));
        output2[i] = item32_to_fc32((input[j++]));
    }
}

DECLARE_CONVERTER(convert_sc16_3_to_item32_1_nswap, PRIORITY_GENERAL){
    const sc16_t *input0 = reinterpret_cast<const sc16_t *>(inputs[0]);
    const sc16_t *input1 = reinterpret_cast<const sc16_t *>(inputs[1]);
    const sc16_t *input2 = reinterpret_cast<const sc16_t *>(inputs[2]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (sc16_to_item32(input0[i]));
        output[j++] = (sc16_to_item32(input1[i]));
        output[j++] = (sc16_to_item32(input2[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_3_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output0 = reinterpret_cast<sc16_t *>(outputs[0]);
    sc16_t *output1 = reinterpret_cast<sc16_t *>(outputs[1]);
    sc16_t *output2 = reinterpret_cast<sc16_t *>(outputs[2]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_sc16((input[j++]));
        output1[i] = item32_to_sc16((input[j++]));
        output2[i] = item32_to_sc16((input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc64_3_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc64_t *input0 = reinterpret_cast<const fc64_t *>(inputs[0]);
    const fc64_t *input1 = reinterpret_cast<const fc64_t *>(inputs[1]);
    const fc64_t *input2 = reinterpret_cast<const fc64_t *>(inputs[2]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(fc64_to_item32(input0[i]));
        output[j++] = uhd::byteswap(fc64_to_item32(input1[i]));
        output[j++] = uhd::byteswap(fc64_to_item32(input2[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_3_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output0 = reinterpret_cast<fc64_t *>(outputs[0]);
    fc64_t *output1 = reinterpret_cast<fc64_t *>(outputs[1]);
    fc64_t *output2 = reinterpret_cast<fc64_t *>(outputs[2]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc64(uhd::byteswap(input[j++]));
        output1[i] = item32_to_fc64(uhd::byteswap(input[j++]));
        output2[i] = item32_to_fc64(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc32_3_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc32_t *input0 = reinterpret_cast<const fc32_t *>(inputs[0]);
    const fc32_t *input1 = reinterpret_cast<const fc32_t *>(inputs[1]);
    const fc32_t *input2 = reinterpret_cast<const fc32_t *>(inputs[2]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(fc32_to_item32(input0[i]));
        output[j++] = uhd::byteswap(fc32_to_item32(input1[i]));
        output[j++] = uhd::byteswap(fc32_to_item32(input2[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_3_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output0 = reinterpret_cast<fc32_t *>(outputs[0]);
    fc32_t *output1 = reinterpret_cast<fc32_t *>(outputs[1]);
    fc32_t *output2 = reinterpret_cast<fc32_t *>(outputs[2]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc32(uhd::byteswap(input[j++]));
        output1[i] = item32_to_fc32(uhd::byteswap(input[j++]));
        output2[i] = item32_to_fc32(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_sc16_3_to_item32_1_bswap, PRIORITY_GENERAL){
    const sc16_t *input0 = reinterpret_cast<const sc16_t *>(inputs[0]);
    const sc16_t *input1 = reinterpret_cast<const sc16_t *>(inputs[1]);
    const sc16_t *input2 = reinterpret_cast<const sc16_t *>(inputs[2]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(sc16_to_item32(input0[i]));
        output[j++] = uhd::byteswap(sc16_to_item32(input1[i]));
        output[j++] = uhd::byteswap(sc16_to_item32(input2[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_3_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output0 = reinterpret_cast<sc16_t *>(outputs[0]);
    sc16_t *output1 = reinterpret_cast<sc16_t *>(outputs[1]);
    sc16_t *output2 = reinterpret_cast<sc16_t *>(outputs[2]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_sc16(uhd::byteswap(input[j++]));
        output1[i] = item32_to_sc16(uhd::byteswap(input[j++]));
        output2[i] = item32_to_sc16(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc64_4_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc64_t *input0 = reinterpret_cast<const fc64_t *>(inputs[0]);
    const fc64_t *input1 = reinterpret_cast<const fc64_t *>(inputs[1]);
    const fc64_t *input2 = reinterpret_cast<const fc64_t *>(inputs[2]);
    const fc64_t *input3 = reinterpret_cast<const fc64_t *>(inputs[3]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (fc64_to_item32(input0[i]));
        output[j++] = (fc64_to_item32(input1[i]));
        output[j++] = (fc64_to_item32(input2[i]));
        output[j++] = (fc64_to_item32(input3[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_4_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output0 = reinterpret_cast<fc64_t *>(outputs[0]);
    fc64_t *output1 = reinterpret_cast<fc64_t *>(outputs[1]);
    fc64_t *output2 = reinterpret_cast<fc64_t *>(outputs[2]);
    fc64_t *output3 = reinterpret_cast<fc64_t *>(outputs[3]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc64((input[j++]));
        output1[i] = item32_to_fc64((input[j++]));
        output2[i] = item32_to_fc64((input[j++]));
        output3[i] = item32_to_fc64((input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc32_4_to_item32_1_nswap, PRIORITY_GENERAL){
    const fc32_t *input0 = reinterpret_cast<const fc32_t *>(inputs[0]);
    const fc32_t *input1 = reinterpret_cast<const fc32_t *>(inputs[1]);
    const fc32_t *input2 = reinterpret_cast<const fc32_t *>(inputs[2]);
    const fc32_t *input3 = reinterpret_cast<const fc32_t *>(inputs[3]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (fc32_to_item32(input0[i]));
        output[j++] = (fc32_to_item32(input1[i]));
        output[j++] = (fc32_to_item32(input2[i]));
        output[j++] = (fc32_to_item32(input3[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_4_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output0 = reinterpret_cast<fc32_t *>(outputs[0]);
    fc32_t *output1 = reinterpret_cast<fc32_t *>(outputs[1]);
    fc32_t *output2 = reinterpret_cast<fc32_t *>(outputs[2]);
    fc32_t *output3 = reinterpret_cast<fc32_t *>(outputs[3]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc32((input[j++]));
        output1[i] = item32_to_fc32((input[j++]));
        output2[i] = item32_to_fc32((input[j++]));
        output3[i] = item32_to_fc32((input[j++]));
    }
}

DECLARE_CONVERTER(convert_sc16_4_to_item32_1_nswap, PRIORITY_GENERAL){
    const sc16_t *input0 = reinterpret_cast<const sc16_t *>(inputs[0]);
    const sc16_t *input1 = reinterpret_cast<const sc16_t *>(inputs[1]);
    const sc16_t *input2 = reinterpret_cast<const sc16_t *>(inputs[2]);
    const sc16_t *input3 = reinterpret_cast<const sc16_t *>(inputs[3]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = (sc16_to_item32(input0[i]));
        output[j++] = (sc16_to_item32(input1[i]));
        output[j++] = (sc16_to_item32(input2[i]));
        output[j++] = (sc16_to_item32(input3[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_4_nswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output0 = reinterpret_cast<sc16_t *>(outputs[0]);
    sc16_t *output1 = reinterpret_cast<sc16_t *>(outputs[1]);
    sc16_t *output2 = reinterpret_cast<sc16_t *>(outputs[2]);
    sc16_t *output3 = reinterpret_cast<sc16_t *>(outputs[3]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_sc16((input[j++]));
        output1[i] = item32_to_sc16((input[j++]));
        output2[i] = item32_to_sc16((input[j++]));
        output3[i] = item32_to_sc16((input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc64_4_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc64_t *input0 = reinterpret_cast<const fc64_t *>(inputs[0]);
    const fc64_t *input1 = reinterpret_cast<const fc64_t *>(inputs[1]);
    const fc64_t *input2 = reinterpret_cast<const fc64_t *>(inputs[2]);
    const fc64_t *input3 = reinterpret_cast<const fc64_t *>(inputs[3]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(fc64_to_item32(input0[i]));
        output[j++] = uhd::byteswap(fc64_to_item32(input1[i]));
        output[j++] = uhd::byteswap(fc64_to_item32(input2[i]));
        output[j++] = uhd::byteswap(fc64_to_item32(input3[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc64_4_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc64_t *output0 = reinterpret_cast<fc64_t *>(outputs[0]);
    fc64_t *output1 = reinterpret_cast<fc64_t *>(outputs[1]);
    fc64_t *output2 = reinterpret_cast<fc64_t *>(outputs[2]);
    fc64_t *output3 = reinterpret_cast<fc64_t *>(outputs[3]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc64(uhd::byteswap(input[j++]));
        output1[i] = item32_to_fc64(uhd::byteswap(input[j++]));
        output2[i] = item32_to_fc64(uhd::byteswap(input[j++]));
        output3[i] = item32_to_fc64(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_fc32_4_to_item32_1_bswap, PRIORITY_GENERAL){
    const fc32_t *input0 = reinterpret_cast<const fc32_t *>(inputs[0]);
    const fc32_t *input1 = reinterpret_cast<const fc32_t *>(inputs[1]);
    const fc32_t *input2 = reinterpret_cast<const fc32_t *>(inputs[2]);
    const fc32_t *input3 = reinterpret_cast<const fc32_t *>(inputs[3]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(fc32_to_item32(input0[i]));
        output[j++] = uhd::byteswap(fc32_to_item32(input1[i]));
        output[j++] = uhd::byteswap(fc32_to_item32(input2[i]));
        output[j++] = uhd::byteswap(fc32_to_item32(input3[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_fc32_4_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    fc32_t *output0 = reinterpret_cast<fc32_t *>(outputs[0]);
    fc32_t *output1 = reinterpret_cast<fc32_t *>(outputs[1]);
    fc32_t *output2 = reinterpret_cast<fc32_t *>(outputs[2]);
    fc32_t *output3 = reinterpret_cast<fc32_t *>(outputs[3]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_fc32(uhd::byteswap(input[j++]));
        output1[i] = item32_to_fc32(uhd::byteswap(input[j++]));
        output2[i] = item32_to_fc32(uhd::byteswap(input[j++]));
        output3[i] = item32_to_fc32(uhd::byteswap(input[j++]));
    }
}

DECLARE_CONVERTER(convert_sc16_4_to_item32_1_bswap, PRIORITY_GENERAL){
    const sc16_t *input0 = reinterpret_cast<const sc16_t *>(inputs[0]);
    const sc16_t *input1 = reinterpret_cast<const sc16_t *>(inputs[1]);
    const sc16_t *input2 = reinterpret_cast<const sc16_t *>(inputs[2]);
    const sc16_t *input3 = reinterpret_cast<const sc16_t *>(inputs[3]);
    item32_t *output = reinterpret_cast<item32_t *>(outputs[0]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output[j++] = uhd::byteswap(sc16_to_item32(input0[i]));
        output[j++] = uhd::byteswap(sc16_to_item32(input1[i]));
        output[j++] = uhd::byteswap(sc16_to_item32(input2[i]));
        output[j++] = uhd::byteswap(sc16_to_item32(input3[i]));
    }
}

DECLARE_CONVERTER(convert_item32_1_to_sc16_4_bswap, PRIORITY_GENERAL){
    const item32_t *input = reinterpret_cast<const item32_t *>(inputs[0]);
    sc16_t *output0 = reinterpret_cast<sc16_t *>(outputs[0]);
    sc16_t *output1 = reinterpret_cast<sc16_t *>(outputs[1]);
    sc16_t *output2 = reinterpret_cast<sc16_t *>(outputs[2]);
    sc16_t *output3 = reinterpret_cast<sc16_t *>(outputs[3]);

    for (size_t i = 0, j = 0; i < nsamps; i++){
        output0[i] = item32_to_sc16(uhd::byteswap(input[j++]));
        output1[i] = item32_to_sc16(uhd::byteswap(input[j++]));
        output2[i] = item32_to_sc16(uhd::byteswap(input[j++]));
        output3[i] = item32_to_sc16(uhd::byteswap(input[j++]));
    }
}
