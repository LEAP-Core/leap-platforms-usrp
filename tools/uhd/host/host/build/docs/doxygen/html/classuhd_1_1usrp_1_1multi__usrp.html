<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>UHD: uhd::usrp::multi_usrp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceuhd.html">uhd</a>::<a class="el" href="namespaceuhd_1_1usrp.html">usrp</a>::<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a>
  </div>
</div>
<div class="contents">
<h1>uhd::usrp::multi_usrp Class Reference</h1><!-- doxytag: class="uhd::usrp::multi_usrp" -->
<p><code>#include &lt;<a class="el" href="multi__usrp_8hpp_source.html">multi_usrp.hpp</a>&gt;</code></p>

<p><a href="classuhd_1_1usrp_1_1multi__usrp-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ac425be38f8e2a3463de440e1f2ae1b6d">get_device</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a99254abfa5259b70a020e667eee619b9">set_master_clock_rate</a> (double rate, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aeefd7580630b2baa4e4c90df3a36d9f0">get_master_clock_rate</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aa22581d58fdf451c3b118add31a6822c">get_pp_string</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abf885b8812408f9ebd471f2902d1cb70">get_mboard_name</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afb4bffe3f969c11ee7c0a2cba5178780">get_time_now</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a55ce95415df2de14a048fca5a04ada03">get_time_last_pps</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a351a2c3081944a0d2caab95e2a2f0926">set_time_now</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aaa80cd6ee4b3c1bf52afb9c3ef02f64d">set_time_next_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a413014bf3aea4a8ea2d268b4a3b390e9">set_time_unknown_pps</a> (const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;time_spec)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acf70237b38918a4b93c37280f6c648b1">get_time_synchronized</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1d335311b77c7c0edfa8a35cac25221b">issue_stream_cmd</a> (const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;stream_cmd)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#aceddf575752fda1a8cc75513a1178fd9">set_clock_config</a> (const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;clock_config, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae4efbbc6480fba44939b34c78d44d7e9">get_num_mboards</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">get_mboard_sensor</a> (const std::string &amp;name, size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">get_mboard_sensor_names</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f94ed00059cc7dd30567d031b3f9679">set_rx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8bacd1b1109656d21da6d5e5f8d417c9">get_rx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#afac94be28eadeccb9c230ce839e072e3">get_rx_num_channels</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a35004bc7e6d418c2c46b2ca0f34db2e6">get_rx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7d2edc68a026061d06a60ea051411e70">set_rx_rate</a> (double rate)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a90d90f4dbee3ac7b00603c8a2c5017e0">get_rx_rate</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9b61448f392466e20572fdcb042e8ec6">set_rx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#adb1c803658f18006efc1dcd67de6d493">get_rx_freq</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">freq_range_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9a5ed2146ac31e641839d00a53df784d">get_rx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad602e7681b796deddd9231f022ffef11">set_rx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a8234968ad1fefef299ef9541cc193915">set_rx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper for setting overall RX gain.  <a href="#a8234968ad1fefef299ef9541cc193915"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4c406b7964f4cc18dc5b57cafcb345c1">get_rx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6483b85f90a3f46d8181a9b57be1db46">get_rx_gain</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain.  <a href="#a6483b85f90a3f46d8181a9b57be1db46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7e077fc7331f7675aa796e030bd8a03e">get_rx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7eb3245ee320e9889a477ba753fd8b8c">get_rx_gain_range</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper for getting overall RX gain range.  <a href="#a7eb3245ee320e9889a477ba753fd8b8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a496745114d83049ed3d0f5fc96e87b2a">get_rx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a72b7947cb0c434b98e9915f91b8f8fe0">set_rx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad2d35d85aebebfdd2d14cee2850243af">get_rx_antenna</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7c1202c5cc978663182adec8c07d8521">get_rx_antennas</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a5bae478b5bed298138ca39a4fce253c5">get_rx_lo_locked</a> (size_t chan=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e026819f286e69c48c2e1956d95c6fb">set_rx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a90d7826c7b96aed88c74ffc035b7f0dd">get_rx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e2df7f4adc46f88eb8db0c6a468c49b">read_rssi</a> (size_t chan=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3299d8f77f1d823c762e36438bac509e">get_rx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">get_rx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">get_rx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3b8d9d9fb9a1ec51e81a207cd299e517">set_tx_subdev_spec</a> (const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;spec, size_t mboard=<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a>)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a070b4bb3cf27436fb9104a414bc9f3f7">get_tx_subdev_spec</a> (size_t mboard=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3be03eb72575c9d5526c93dd133e96d3">get_tx_num_channels</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4b0632b6ddff26e9d0bd22990274f99d">get_tx_subdev_name</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a51b528b6738bf895e0ff4d7d592b4ab8">set_tx_rate</a> (double rate)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9108966751204a8c0069dbac806152cd">get_tx_rate</a> (void)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae7a674a9d012a78dd4f2ded478839124">set_tx_freq</a> (const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;tune_request, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9ac9b0e10e67d967c06e8dd6511b5919">get_tx_freq</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">freq_range_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a898502a489319cd64230bb0e50d9ab0a">get_tx_freq_range</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a41cc3c774451d0a2c5f69cd8df0f9f06">set_tx_gain</a> (double gain, const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a1101dc00b016fe91a299cbcae8b12053">set_tx_gain</a> (double gain, size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper for setting overall TX gain.  <a href="#a1101dc00b016fe91a299cbcae8b12053"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ae88320fb12dd6ebfc4b9f6bc4074f11b">get_tx_gain</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a612c00086f9968380bcf51f877b544b7">get_tx_gain</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain.  <a href="#a612c00086f9968380bcf51f877b544b7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ab99753a578657046f7a0ce72f666abdc">get_tx_gain_range</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a6ec9889b9b64d1d8e2a308c0b0c328ec">get_tx_gain_range</a> (size_t chan=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience wrapper for getting overall TX gain range.  <a href="#a6ec9889b9b64d1d8e2a308c0b0c328ec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9f5589722a2a1491fc393a6b98f094b0">get_tx_gain_names</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a4e8cd16aa93bf3375cdcd3daca3b6b24">set_tx_antenna</a> (const std::string &amp;ant, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a7f3e6094ff76cc3d0630e46cb291bcfd">get_tx_antenna</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a38b10a6bd2128b3810da229c60b31aa1">get_tx_antennas</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a43f565611c0c3b5679f5d770b0835ca0">get_tx_lo_locked</a> (size_t chan=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#ad04bfc300735435a7937d4eb37e5523d">set_tx_bandwidth</a> (double bandwidth, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a227fd46437f562b8f8f6d4a98cd1c5dc">get_tx_bandwidth</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#abe3261f1f763a026707dea80ac466d1c">get_tx_dboard_iface</a> (size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">get_tx_sensor</a> (const std::string &amp;name, size_t chan=0)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">get_tx_sensor_names</a> (size_t chan=0)=0</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">make</a> (const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;dev_addr)</td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a> = size_t(~0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wildcard motherboard index.  <a href="#a21f2ba01462e1f211a8823fda24a82d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a524b7e2177492e59382f1124ee32c12b">ALL_GAINS</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wildcard gain element name.  <a href="#a524b7e2177492e59382f1124ee32c12b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The Multi-USRP device class:</p>
<p>This class facilitates ease-of-use for most use-case scenarios. The wrapper provides convenience functions to tune the devices, set the dboard gains, antennas, filters, and other properties. This class can be used to interface with a single USRP with one or more channels, or multiple USRPs in a homogeneous setup. All members take an optional parameter for board number or channel number. In the single device, single channel case, these parameters can be unspecified.</p>
<p>When using a single device with multiple channels:</p>
<ul>
<li>Channel mapping is determined by the subdevice specifications</li>
<li>All channels share a common RX sample rate</li>
<li>All channels share a common TX sample rate</li>
</ul>
<p>When using multiple devices in a configuration:</p>
<ul>
<li>Channel mapping is determined by the device address arguments</li>
<li>All boards share a common RX sample rate</li>
<li>All boards share a common TX sample rate</li>
<li>All boards share a common RX subdevice specification size</li>
<li>All boards share a common TX subdevice specification size</li>
<li>All boards must have synchronized times (see the set_time_*() calls)</li>
</ul>
<p>Example to setup channel mapping for multiple devices: </p>
<pre></pre><pre> //create a <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a> with two boards in the configuration
 <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> dev_addr;
 dev_addr["addr0"] = "192.168.10.2"
 dev_addr["addr1"] = "192.168.10.3";
 <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">multi_usrp::sptr</a> dev = multi_usrp::make(dev_addr);</pre><pre> //set the board on 10.2 to use the A RX subdevice (RX channel 0)
 dev-&gt;set_rx_subdev_spec(":A", 0);</pre><pre> //set the board on 10.3 to use the B RX subdevice (RX channel 1)
 dev-&gt;set_rx_subdev_spec(":B", 1);</pre><pre> //set both boards to use the AB TX subdevice (TX channels 0 and 1)
 dev-&gt;set_tx_subdev_spec(":AB", <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5" title="A wildcard motherboard index.">multi_usrp::ALL_MBOARDS</a>);</pre><pre> //now that all the channels are mapped, continue with configuration...</pre><pre> </pre> <hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9d9112f5eac0b53a721f2a6c97021fc1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::sptr" ref="a9d9112f5eac0b53a721f2a6c97021fc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">multi_usrp</a>&gt; <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">uhd::usrp::multi_usrp::sptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac425be38f8e2a3463de440e1f2ae1b6d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_device" ref="ac425be38f8e2a3463de440e1f2ae1b6d" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">device::sptr</a> uhd::usrp::multi_usrp::get_device </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the underlying device object. This is needed to get access to the streaming API and properties. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the device object within this single usrp </dd></dl>

</div>
</div>
<a class="anchor" id="aeefd7580630b2baa4e4c90df3a36d9f0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_master_clock_rate" ref="aeefd7580630b2baa4e4c90df3a36d9f0" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_master_clock_rate </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the master clock rate. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the master clock rate in Hz. </dd></dl>

</div>
</div>
<a class="anchor" id="abf885b8812408f9ebd471f2902d1cb70"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_mboard_name" ref="abf885b8812408f9ebd471f2902d1cb70" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_mboard_name </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get canonical name for this USRP motherboard. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a string representing the name </dd></dl>

</div>
</div>
<a class="anchor" id="a2d3c327bcb83fd274e05e3ca95d1ac95"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_mboard_sensor" ref="a2d3c327bcb83fd274e05e3ca95d1ac95" args="(const std::string &amp;name, size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_mboard_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a motherboard sensor value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the sensor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a3a72259c19b80512dba02e40ed5cf028"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_mboard_sensor_names" ref="a3a72259c19b80512dba02e40ed5cf028" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_mboard_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible motherboard sensor names. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="ae4efbbc6480fba44939b34c78d44d7e9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_num_mboards" ref="ae4efbbc6480fba44939b34c78d44d7e9" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_num_mboards </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of USRP motherboards in this configuration. </p>

</div>
</div>
<a class="anchor" id="aa22581d58fdf451c3b118add31a6822c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_pp_string" ref="aa22581d58fdf451c3b118add31a6822c" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_pp_string </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a printable summary for this USRP configuration. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a printable string </dd></dl>

</div>
</div>
<a class="anchor" id="ad2d35d85aebebfdd2d14cee2850243af"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_antenna" ref="ad2d35d85aebebfdd2d14cee2850243af" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_rx_antenna </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the selected RX antenna on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the antenna name </dd></dl>

</div>
</div>
<a class="anchor" id="a7c1202c5cc978663182adec8c07d8521"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_antennas" ref="a7c1202c5cc978663182adec8c07d8521" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_antennas </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible RX antennas on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a class="anchor" id="a90d7826c7b96aed88c74ffc035b7f0dd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_bandwidth" ref="a90d7826c7b96aed88c74ffc035b7f0dd" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX bandwidth on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a3299d8f77f1d823c762e36438bac509e"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_dboard_iface" ref="a3299d8f77f1d823c762e36438bac509e" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> uhd::usrp::multi_usrp::get_rx_dboard_iface </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the dboard interface object for the RX subdevice. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a class="anchor" id="adb1c803658f18006efc1dcd67de6d493"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_freq" ref="adb1c803658f18006efc1dcd67de6d493" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_freq </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX center frequency. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a9a5ed2146ac31e641839d00a53df784d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_freq_range" ref="a9a5ed2146ac31e641839d00a53df784d" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">freq_range_t</a> uhd::usrp::multi_usrp::get_rx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX center frequency range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="a6483b85f90a3f46d8181a9b57be1db46"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain" ref="a6483b85f90a3f46d8181a9b57be1db46" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double uhd::usrp::multi_usrp::get_rx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall RX gain. </p>

</div>
</div>
<a class="anchor" id="a4c406b7964f4cc18dc5b57cafcb345c1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain" ref="a4c406b7964f4cc18dc5b57cafcb345c1" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_gain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX gain value for the specified gain element. For an empty name, sum across all gain elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the gain element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a class="anchor" id="a496745114d83049ed3d0f5fc96e87b2a"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain_names" ref="a496745114d83049ed3d0f5fc96e87b2a" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_gain_names </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the names of the gain elements in the RX chain. Gain elements are ordered from antenna to FPGA. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a class="anchor" id="a7eb3245ee320e9889a477ba753fd8b8c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain_range" ref="a7eb3245ee320e9889a477ba753fd8b8c" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a> uhd::usrp::multi_usrp::get_rx_gain_range </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall RX gain range. </p>

</div>
</div>
<a class="anchor" id="a7e077fc7331f7675aa796e030bd8a03e"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_gain_range" ref="a7e077fc7331f7675aa796e030bd8a03e" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a> uhd::usrp::multi_usrp::get_rx_gain_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the gain element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a gain range object </dd></dl>

</div>
</div>
<a class="anchor" id="a5bae478b5bed298138ca39a4fce253c5"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_lo_locked" ref="a5bae478b5bed298138ca39a4fce253c5" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uhd::usrp::multi_usrp::get_rx_lo_locked </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the locked status of the LO on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true for locked </dd></dl>

</div>
</div>
<a class="anchor" id="afac94be28eadeccb9c230ce839e072e3"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_num_channels" ref="afac94be28eadeccb9c230ce839e072e3" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_rx_num_channels </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of RX channels in this configuration. This is the number of USRPs times the number of RX channels per board, where the number of RX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a class="anchor" id="a90d90f4dbee3ac7b00603c8a2c5017e0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_rate" ref="a90d90f4dbee3ac7b00603c8a2c5017e0" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_rx_rate </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the RX sample rate for all channels. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a class="anchor" id="acd37d327931cec64e3701eb2a5aa7bfb"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_sensor" ref="acd37d327931cec64e3701eb2a5aa7bfb" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_rx_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an RX subdevice sensor value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the sensor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a87d3d097b6cb1cfa940896e71e5f44ad"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_sensor_names" ref="a87d3d097b6cb1cfa940896e71e5f44ad" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_rx_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible RX subdevice sensor names. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="a35004bc7e6d418c2c46b2ca0f34db2e6"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_subdev_name" ref="a35004bc7e6d418c2c46b2ca0f34db2e6" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_rx_subdev_name </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of the RX subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the subdevice name </dd></dl>

</div>
</div>
<a class="anchor" id="a8bacd1b1109656d21da6d5e5f8d417c9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_rx_subdev_spec" ref="a8bacd1b1109656d21da6d5e5f8d417c9" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> uhd::usrp::multi_usrp::get_rx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the RX subdevice specification. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the subdevice specification in use </dd></dl>

</div>
</div>
<a class="anchor" id="a55ce95415df2de14a048fca5a04ada03"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_last_pps" ref="a55ce95415df2de14a048fca5a04ada03" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> uhd::usrp::multi_usrp::get_time_last_pps </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the time when the last pps pulse occured. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a timespec representing the last pps </dd></dl>

</div>
</div>
<a class="anchor" id="afb4bffe3f969c11ee7c0a2cba5178780"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_now" ref="afb4bffe3f969c11ee7c0a2cba5178780" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> uhd::usrp::multi_usrp::get_time_now </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current time in the usrp time registers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>which motherboard to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a timespec representing current usrp time </dd></dl>

</div>
</div>
<a class="anchor" id="acf70237b38918a4b93c37280f6c648b1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_time_synchronized" ref="acf70237b38918a4b93c37280f6c648b1" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::usrp::multi_usrp::get_time_synchronized </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Are the times across all motherboards in this configuration synchronized? Checks that all time registers are approximately close but not exact, given that the RTT may varying for a control packet transaction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true when all motherboards time registers are in sync </dd></dl>

</div>
</div>
<a class="anchor" id="a7f3e6094ff76cc3d0630e46cb291bcfd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_antenna" ref="a7f3e6094ff76cc3d0630e46cb291bcfd" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_tx_antenna </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the selected TX antenna on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the antenna name </dd></dl>

</div>
</div>
<a class="anchor" id="a38b10a6bd2128b3810da229c60b31aa1"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_antennas" ref="a38b10a6bd2128b3810da229c60b31aa1" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_antennas </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible TX antennas on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of antenna names </dd></dl>

</div>
</div>
<a class="anchor" id="a227fd46437f562b8f8f6d4a98cd1c5dc"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_bandwidth" ref="a227fd46437f562b8f8f6d4a98cd1c5dc" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX bandwidth on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the bandwidth in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="abe3261f1f763a026707dea80ac466d1c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_dboard_iface" ref="abe3261f1f763a026707dea80ac466d1c" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1dboard__iface.html#a59c880b1ce74b17f9aec67426d37a4c8">dboard_iface::sptr</a> uhd::usrp::multi_usrp::get_tx_dboard_iface </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the dboard interface object for the TX subdevice. The dboard interface gives access to GPIOs, SPI, I2C, low-speed ADC and DAC. Use at your own risk! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the dboard interface sptr </dd></dl>

</div>
</div>
<a class="anchor" id="a9ac9b0e10e67d967c06e8dd6511b5919"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_freq" ref="a9ac9b0e10e67d967c06e8dd6511b5919" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_freq </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX center frequency. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the frequency in Hz </dd></dl>

</div>
</div>
<a class="anchor" id="a898502a489319cd64230bb0e50d9ab0a"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_freq_range" ref="a898502a489319cd64230bb0e50d9ab0a" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">freq_range_t</a> uhd::usrp::multi_usrp::get_tx_freq_range </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX center frequency range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a frequency range object </dd></dl>

</div>
</div>
<a class="anchor" id="a612c00086f9968380bcf51f877b544b7"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain" ref="a612c00086f9968380bcf51f877b544b7" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double uhd::usrp::multi_usrp::get_tx_gain </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall TX gain. </p>

</div>
</div>
<a class="anchor" id="ae88320fb12dd6ebfc4b9f6bc4074f11b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain" ref="ae88320fb12dd6ebfc4b9f6bc4074f11b" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_gain </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX gain value for the specified gain element. For an empty name, sum across all gain elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the gain element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the gain in dB </dd></dl>

</div>
</div>
<a class="anchor" id="a9f5589722a2a1491fc393a6b98f094b0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain_names" ref="a9f5589722a2a1491fc393a6b98f094b0" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_gain_names </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the names of the gain elements in the TX chain. Gain elements are ordered from antenna to FPGA. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of gain element names </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec9889b9b64d1d8e2a308c0b0c328ec"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain_range" ref="a6ec9889b9b64d1d8e2a308c0b0c328ec" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a> uhd::usrp::multi_usrp::get_tx_gain_range </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for getting overall TX gain range. </p>

</div>
</div>
<a class="anchor" id="ab99753a578657046f7a0ce72f666abdc"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_gain_range" ref="ab99753a578657046f7a0ce72f666abdc" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1meta__range__t.html">gain_range_t</a> uhd::usrp::multi_usrp::get_tx_gain_range </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX gain range for the specified gain element. For an empty name, calculate the overall gain range. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the gain element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a gain range object </dd></dl>

</div>
</div>
<a class="anchor" id="a43f565611c0c3b5679f5d770b0835ca0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_lo_locked" ref="a43f565611c0c3b5679f5d770b0835ca0" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool uhd::usrp::multi_usrp::get_tx_lo_locked </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the locked status of the LO on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true for locked </dd></dl>

</div>
</div>
<a class="anchor" id="a3be03eb72575c9d5526c93dd133e96d3"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_num_channels" ref="a3be03eb72575c9d5526c93dd133e96d3" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::usrp::multi_usrp::get_tx_num_channels </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the number of TX channels in this configuration. This is the number of USRPs times the number of TX channels per board, where the number of TX channels per board is homogeneous among all USRPs. </p>

</div>
</div>
<a class="anchor" id="a9108966751204a8c0069dbac806152cd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_rate" ref="a9108966751204a8c0069dbac806152cd" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double uhd::usrp::multi_usrp::get_tx_rate </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the TX sample rate for all channels. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the rate in Sps </dd></dl>

</div>
</div>
<a class="anchor" id="a482d52c0983c6db913209e57f9b79c3a"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_sensor" ref="a482d52c0983c6db913209e57f9b79c3a" args="(const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1sensor__value__t.html">sensor_value_t</a> uhd::usrp::multi_usrp::get_tx_sensor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an TX subdevice sensor value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the sensor </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a sensor value object </dd></dl>

</div>
</div>
<a class="anchor" id="a33a556057ceabc00ab2af61525f206fd"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_sensor_names" ref="a33a556057ceabc00ab2af61525f206fd" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; uhd::usrp::multi_usrp::get_tx_sensor_names </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of possible TX subdevice sensor names. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of sensor names </dd></dl>

</div>
</div>
<a class="anchor" id="a4b0632b6ddff26e9d0bd22990274f99d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_subdev_name" ref="a4b0632b6ddff26e9d0bd22990274f99d" args="(size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string uhd::usrp::multi_usrp::get_tx_subdev_name </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the name of the TX subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the subdevice name </dd></dl>

</div>
</div>
<a class="anchor" id="a070b4bb3cf27436fb9104a414bc9f3f7"></a><!-- doxytag: member="uhd::usrp::multi_usrp::get_tx_subdev_spec" ref="a070b4bb3cf27436fb9104a414bc9f3f7" args="(size_t mboard=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> uhd::usrp::multi_usrp::get_tx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the TX subdevice specification. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the subdevice specification in use </dd></dl>

</div>
</div>
<a class="anchor" id="a1d335311b77c7c0edfa8a35cac25221b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::issue_stream_cmd" ref="a1d335311b77c7c0edfa8a35cac25221b" args="(const stream_cmd_t &amp;stream_cmd)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::issue_stream_cmd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>stream_cmd</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Issue a stream command to the usrp device. This tells the usrp to send samples into the host. See the documentation for <a class="el" href="structuhd_1_1stream__cmd__t.html">stream_cmd_t</a> for more info.</p>
<p>With multiple devices, the first stream command in a chain of commands should have a time spec in the near future and stream_now = false; to ensure that the packets can be aligned by their time specs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream_cmd</em>&nbsp;</td><td>the stream command to issue </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0d3809a8f8dcd3c962ad5b9a0a6456c"></a><!-- doxytag: member="uhd::usrp::multi_usrp::make" ref="af0d3809a8f8dcd3c962ad5b9a0a6456c" args="(const device_addr_t &amp;dev_addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a9d9112f5eac0b53a721f2a6c97021fc1">sptr</a> uhd::usrp::multi_usrp::make </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dev_addr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a new multi usrp from the device address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dev_addr</em>&nbsp;</td><td>the device address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a new single usrp object </dd></dl>

</div>
</div>
<a class="anchor" id="a4e2df7f4adc46f88eb8db0c6a468c49b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::read_rssi" ref="a4e2df7f4adc46f88eb8db0c6a468c49b" args="(size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double uhd::usrp::multi_usrp::read_rssi </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the RSSI value on the RX subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the rssi in dB </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>exception</em>&nbsp;</td><td>if RSSI readback not supported </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aceddf575752fda1a8cc75513a1178fd9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_clock_config" ref="aceddf575752fda1a8cc75513a1178fd9" args="(const clock_config_t &amp;clock_config, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_clock_config </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>clock_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the clock configuration for the usrp device. This tells the usrp how to get a 10Mhz reference and PPS clock. See the documentation for <a class="el" href="structuhd_1_1clock__config__t.html">clock_config_t</a> for more info. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>clock_config</em>&nbsp;</td><td>the clock configuration to set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>which motherboard to set the config </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99254abfa5259b70a020e667eee619b9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_master_clock_rate" ref="a99254abfa5259b70a020e667eee619b9" args="(double rate, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_master_clock_rate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the master clock rate. This controls the rate of the clock that feeds the FPGA DSP. On some devices, this re-tunes the clock to the specified rate. If the specified rate is not available, this method will throw. On other devices, this method notifies the software of the rate, but requires the the user has made the necessary hardware change. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>the new master clock rate in Hz </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72b7947cb0c434b98e9915f91b8f8fe0"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_antenna" ref="a72b7947cb0c434b98e9915f91b8f8fe0" args="(const std::string &amp;ant, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_antenna </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Select the RX antenna on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ant</em>&nbsp;</td><td>the antenna name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e026819f286e69c48c2e1956d95c6fb"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_bandwidth" ref="a4e026819f286e69c48c2e1956d95c6fb" args="(double bandwidth, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX bandwidth on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bandwidth</em>&nbsp;</td><td>the bandwidth in Hz </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b61448f392466e20572fdcb042e8ec6"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_freq" ref="a9b61448f392466e20572fdcb042e8ec6" args="(const tune_request_t &amp;tune_request, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> uhd::usrp::multi_usrp::set_rx_freq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX center frequency. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tune_request</em>&nbsp;</td><td>tune request instructions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tune result object </dd></dl>

</div>
</div>
<a class="anchor" id="a8234968ad1fefef299ef9541cc193915"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_gain" ref="a8234968ad1fefef299ef9541cc193915" args="(double gain, size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uhd::usrp::multi_usrp::set_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for setting overall RX gain. </p>

</div>
</div>
<a class="anchor" id="ad602e7681b796deddd9231f022ffef11"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_gain" ref="ad602e7681b796deddd9231f022ffef11" args="(double gain, const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_gain </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gain</em>&nbsp;</td><td>the gain in dB </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the gain element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d2edc68a026061d06a60ea051411e70"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_rate" ref="a7d2edc68a026061d06a60ea051411e70" args="(double rate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_rate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rate</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX sample rate across all channels. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>the rate in Sps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f94ed00059cc7dd30567d031b3f9679"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_rx_subdev_spec" ref="a7f94ed00059cc7dd30567d031b3f9679" args="(const uhd::usrp::subdev_spec_t &amp;spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_rx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the RX subdevice specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>the new subdevice specification </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa80cd6ee4b3c1bf52afb9c3ef02f64d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_time_next_pps" ref="aaa80cd6ee4b3c1bf52afb9c3ef02f64d" args="(const time_spec_t &amp;time_spec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_next_pps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time_spec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the time registers on the usrp at the next pps tick. The values will not be latched in until the pulse occurs. It is recommended that the user sleep(1) after calling to ensure that the time registers will be in a known state prior to use.</p>
<p>Note: Because this call sets the time on the "next" pps, the seconds in the time spec should be current seconds + 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time_spec</em>&nbsp;</td><td>the time to latch into the usrp device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a351a2c3081944a0d2caab95e2a2f0926"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_time_now" ref="a351a2c3081944a0d2caab95e2a2f0926" args="(const time_spec_t &amp;time_spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_now </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the time registers on the usrp immediately.</p>
<p>If only one MIMO master is present in your configuration, set_time_now is safe to use because the slave's time automatically follows the master's time. Otherwise, this call cannot set the time synchronously across multiple devices. Please use the set_time_next_pps or set_time_unknown_pps calls with a PPS signal.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time_spec</em>&nbsp;</td><td>the time to latch into the usrp device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a413014bf3aea4a8ea2d268b4a3b390e9"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_time_unknown_pps" ref="a413014bf3aea4a8ea2d268b4a3b390e9" args="(const time_spec_t &amp;time_spec)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_time_unknown_pps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1time__spec__t.html">time_spec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>time_spec</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Synchronize the times across all motherboards in this configuration. Use this method to sync the times when the edge of the PPS is unknown.</p>
<p>Ex: Host machine is not attached to serial port of GPSDO and can therefore not query the GPSDO for the PPS edge.</p>
<p>This is a 2-step process, and will take at most 2 seconds to complete. Upon completion, the times will be synchronized to the time provided.</p>
<ul>
<li>Step1: wait for the last pps time to transition to catch the edge</li>
<li>Step2: set the time at the next pps (synchronous for all boards)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>time_spec</em>&nbsp;</td><td>the time to latch at the next pps after catching the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e8cd16aa93bf3375cdcd3daca3b6b24"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_antenna" ref="a4e8cd16aa93bf3375cdcd3daca3b6b24" args="(const std::string &amp;ant, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_antenna </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>ant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Select the TX antenna on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ant</em>&nbsp;</td><td>the antenna name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad04bfc300735435a7937d4eb37e5523d"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_bandwidth" ref="ad04bfc300735435a7937d4eb37e5523d" args="(double bandwidth, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_bandwidth </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>bandwidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX bandwidth on the subdevice. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bandwidth</em>&nbsp;</td><td>the bandwidth in Hz </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7a674a9d012a78dd4f2ded478839124"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_freq" ref="ae7a674a9d012a78dd4f2ded478839124" args="(const tune_request_t &amp;tune_request, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structuhd_1_1tune__result__t.html">tune_result_t</a> uhd::usrp::multi_usrp::set_tx_freq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tune__request__t.html">tune_request_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>tune_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX center frequency. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tune_request</em>&nbsp;</td><td>tune request instructions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a tune result object </dd></dl>

</div>
</div>
<a class="anchor" id="a1101dc00b016fe91a299cbcae8b12053"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_gain" ref="a1101dc00b016fe91a299cbcae8b12053" args="(double gain, size_t chan=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void uhd::usrp::multi_usrp::set_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A convenience wrapper for setting overall TX gain. </p>

</div>
</div>
<a class="anchor" id="a41cc3c774451d0a2c5f69cd8df0f9f06"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_gain" ref="a41cc3c774451d0a2c5f69cd8df0f9f06" args="(double gain, const std::string &amp;name, size_t chan=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_gain </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>chan</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX gain value for the specified gain element. For an empty name, distribute across all gain elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gain</em>&nbsp;</td><td>the gain in dB </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the name of the gain element </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chan</em>&nbsp;</td><td>the channel index 0 to N-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51b528b6738bf895e0ff4d7d592b4ab8"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_rate" ref="a51b528b6738bf895e0ff4d7d592b4ab8" args="(double rate)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_rate </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>rate</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX sample rate across all channels. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rate</em>&nbsp;</td><td>the rate in Sps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b8d9d9fb9a1ec51e81a207cd299e517"></a><!-- doxytag: member="uhd::usrp::multi_usrp::set_tx_subdev_spec" ref="a3b8d9d9fb9a1ec51e81a207cd299e517" args="(const uhd::usrp::subdev_spec_t &amp;spec, size_t mboard=ALL_MBOARDS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uhd::usrp::multi_usrp::set_tx_subdev_spec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>mboard</em> = <code><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">ALL_MBOARDS</a></code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the TX subdevice specification: The subdev spec maps a physical part of a daughter-board to a channel number. Set the subdev spec before calling into any methods with a channel number. The subdev spec must be the same size across all motherboards. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spec</em>&nbsp;</td><td>the new subdevice specification </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mboard</em>&nbsp;</td><td>the motherboard index 0 to M-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a524b7e2177492e59382f1124ee32c12b"></a><!-- doxytag: member="uhd::usrp::multi_usrp::ALL_GAINS" ref="a524b7e2177492e59382f1124ee32c12b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a524b7e2177492e59382f1124ee32c12b">uhd::usrp::multi_usrp::ALL_GAINS</a><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A wildcard gain element name. </p>

</div>
</div>
<a class="anchor" id="a21f2ba01462e1f211a8823fda24a82d5"></a><!-- doxytag: member="uhd::usrp::multi_usrp::ALL_MBOARDS" ref="a21f2ba01462e1f211a8823fda24a82d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a21f2ba01462e1f211a8823fda24a82d5">uhd::usrp::multi_usrp::ALL_MBOARDS</a> = size_t(~0)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A wildcard motherboard index. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/uhd/usrp/<a class="el" href="multi__usrp_8hpp_source.html">multi_usrp.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Apr 2 14:36:27 2011 for UHD by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
