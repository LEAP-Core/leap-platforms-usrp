<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>UHD: uhd::device Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceuhd.html">uhd</a>::<a class="el" href="classuhd_1_1device.html">device</a>
  </div>
</div>
<div class="contents">
<h1>uhd::device Class Reference</h1><!-- doxytag: class="uhd::device" --><!-- doxytag: inherits="wax::obj" -->
<p><code>#include &lt;<a class="el" href="device_8hpp_source.html">device.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for uhd::device:</div>
<div class="dynsection">
 <div class="center">
  <img src="classuhd_1_1device.png" usemap="#uhd::device_map" alt=""/>
  <map id="uhd::device_map" name="uhd::device_map">
<area href="classwax_1_1obj.html" alt="wax::obj" shape="rect" coords="0,0,77,24"/>
</map>
 </div>
</div>

<p><a href="classuhd_1_1device-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#af90bb04b825e781235018bd90980e262">send_mode_t</a> { <a class="el" href="classuhd_1_1device.html#af90bb04b825e781235018bd90980e262a80d3d8408572ff4b9b9ec1e5c95bd461">SEND_MODE_FULL_BUFF</a> =  0, 
<a class="el" href="classuhd_1_1device.html#af90bb04b825e781235018bd90980e262aac81a64f198acd212a233de0916d8c7c">SEND_MODE_ONE_PACKET</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a3a59c1d7f04646fa7ebf7ce668362dc2">recv_mode_t</a> { <a class="el" href="classuhd_1_1device.html#a3a59c1d7f04646fa7ebf7ce668362dc2ab2f2c5025018749557a10cd76e827b90">RECV_MODE_FULL_BUFF</a> =  0, 
<a class="el" href="classuhd_1_1device.html#a3a59c1d7f04646fa7ebf7ce668362dc2a7cf9217bbbc09f20be9df4d73686aabb">RECV_MODE_ONE_PACKET</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr&lt; <a class="el" href="classuhd_1_1device.html">device</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">sptr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function<br class="typebreak"/>
&lt; <a class="el" href="namespaceuhd.html#af4fc6d6f813e411184c069ba39901737">device_addrs_t</a>(const <br class="typebreak"/>
<a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a7cab70fce4219ff5910460724d09ee20">find_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef boost::function&lt; <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">sptr</a>(const <br class="typebreak"/>
<a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#aa57d1d2a3f5774df16fbdecacbe38d5d">make_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classuhd_1_1ref__vector.html">ref_vector</a>&lt; const void * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#acfdee43cd5b008cd866d943a56f4cbd6">send_buffs_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for a pointer to a single, or a collection of send buffers.  <a href="#acfdee43cd5b008cd866d943a56f4cbd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classuhd_1_1ref__vector.html">ref_vector</a>&lt; void * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#ab9d50131a9e72e57a9663f92787313f3">recv_buffs_type</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Typedef for a pointer to a single, or a collection of recv buffers.  <a href="#ab9d50131a9e72e57a9663f92787313f3"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a1d302f283c89b0823c9745dc395ae679">send</a> (const <a class="el" href="classuhd_1_1ref__vector.html">send_buffs_type</a> &amp;buffs, size_t nsamps_per_buff, const <a class="el" href="structuhd_1_1tx__metadata__t.html">tx_metadata_t</a> &amp;metadata, const <a class="el" href="classuhd_1_1io__type__t.html">io_type_t</a> &amp;io_type, <a class="el" href="classuhd_1_1device.html#af90bb04b825e781235018bd90980e262">send_mode_t</a> send_mode, double timeout=0.1)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a3e7e55ed84ca59310c4396a18a5e36d5">recv</a> (const <a class="el" href="classuhd_1_1ref__vector.html">recv_buffs_type</a> &amp;buffs, size_t nsamps_per_buff, <a class="el" href="structuhd_1_1rx__metadata__t.html">rx_metadata_t</a> &amp;metadata, const <a class="el" href="classuhd_1_1io__type__t.html">io_type_t</a> &amp;io_type, <a class="el" href="classuhd_1_1device.html#a3a59c1d7f04646fa7ebf7ce668362dc2">recv_mode_t</a> recv_mode, double timeout=0.1)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a70d89a8eca9079a026899860d10bd9a7">get_max_send_samps_per_packet</a> (void) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#ab53d8cc7dc9bc12d52bc2ab4fdf55062">get_max_recv_samps_per_packet</a> (void) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a18f94b4369ebfa03358b06bef000dacd">recv_async_msg</a> (<a class="el" href="structuhd_1_1async__metadata__t.html">async_metadata_t</a> &amp;async_metadata, double timeout=0.1)=0</td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a14097018989427c5b6e8311265a88961">register_device</a> (const <a class="el" href="classuhd_1_1device.html#a7cab70fce4219ff5910460724d09ee20">find_t</a> &amp;find, const <a class="el" href="classuhd_1_1device.html#aa57d1d2a3f5774df16fbdecacbe38d5d">make_t</a> &amp;make)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceuhd.html#af4fc6d6f813e411184c069ba39901737">device_addrs_t</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#a3da49ce274ae8a014a14a9ef1bb2a3e7">find</a> (const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;hint)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find usrp devices attached to the host.  <a href="#a3da49ce274ae8a014a14a9ef1bb2a3e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">sptr</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classuhd_1_1device.html#ad267bb32c7c9d7f4f24b4e29fdbcf3ec">make</a> (const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;hint, size_t which=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new usrp device from the device address hint.  <a href="#ad267bb32c7c9d7f4f24b4e29fdbcf3ec"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The usrp device interface represents the usrp hardware. The api allows for discovery, configuration, and streaming. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a7cab70fce4219ff5910460724d09ee20"></a><!-- doxytag: member="uhd::device::find_t" ref="a7cab70fce4219ff5910460724d09ee20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;<a class="el" href="namespaceuhd.html#af4fc6d6f813e411184c069ba39901737">device_addrs_t</a>(const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;)&gt; <a class="el" href="classuhd_1_1device.html#a7cab70fce4219ff5910460724d09ee20">uhd::device::find_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa57d1d2a3f5774df16fbdecacbe38d5d"></a><!-- doxytag: member="uhd::device::make_t" ref="aa57d1d2a3f5774df16fbdecacbe38d5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::function&lt;<a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">sptr</a>(const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;)&gt; <a class="el" href="classuhd_1_1device.html#aa57d1d2a3f5774df16fbdecacbe38d5d">uhd::device::make_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab9d50131a9e72e57a9663f92787313f3"></a><!-- doxytag: member="uhd::device::recv_buffs_type" ref="ab9d50131a9e72e57a9663f92787313f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classuhd_1_1ref__vector.html">ref_vector</a>&lt;void *&gt; <a class="el" href="classuhd_1_1ref__vector.html">uhd::device::recv_buffs_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef for a pointer to a single, or a collection of recv buffers. </p>

</div>
</div>
<a class="anchor" id="acfdee43cd5b008cd866d943a56f4cbd6"></a><!-- doxytag: member="uhd::device::send_buffs_type" ref="acfdee43cd5b008cd866d943a56f4cbd6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classuhd_1_1ref__vector.html">ref_vector</a>&lt;const void *&gt; <a class="el" href="classuhd_1_1ref__vector.html">uhd::device::send_buffs_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Typedef for a pointer to a single, or a collection of send buffers. </p>

</div>
</div>
<a class="anchor" id="a439ff67bbcbe999d871a179467355ed0"></a><!-- doxytag: member="uhd::device::sptr" ref="a439ff67bbcbe999d871a179467355ed0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt;<a class="el" href="classuhd_1_1device.html">device</a>&gt; <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">uhd::device::sptr</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a3a59c1d7f04646fa7ebf7ce668362dc2"></a><!-- doxytag: member="uhd::device::recv_mode_t" ref="a3a59c1d7f04646fa7ebf7ce668362dc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classuhd_1_1device.html#a3a59c1d7f04646fa7ebf7ce668362dc2">uhd::device::recv_mode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Recv modes for the device recv routine. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3a59c1d7f04646fa7ebf7ce668362dc2ab2f2c5025018749557a10cd76e827b90"></a><!-- doxytag: member="RECV_MODE_FULL_BUFF" ref="a3a59c1d7f04646fa7ebf7ce668362dc2ab2f2c5025018749557a10cd76e827b90" args="" -->RECV_MODE_FULL_BUFF</em>&nbsp;</td><td>
<p>Tells the recv routine to recv the entire buffer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3a59c1d7f04646fa7ebf7ce668362dc2a7cf9217bbbc09f20be9df4d73686aabb"></a><!-- doxytag: member="RECV_MODE_ONE_PACKET" ref="a3a59c1d7f04646fa7ebf7ce668362dc2a7cf9217bbbc09f20be9df4d73686aabb" args="" -->RECV_MODE_ONE_PACKET</em>&nbsp;</td><td>
<p>Tells the recv routine to return after one packet. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="af90bb04b825e781235018bd90980e262"></a><!-- doxytag: member="uhd::device::send_mode_t" ref="af90bb04b825e781235018bd90980e262" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classuhd_1_1device.html#af90bb04b825e781235018bd90980e262">uhd::device::send_mode_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send modes for the device send routine. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af90bb04b825e781235018bd90980e262a80d3d8408572ff4b9b9ec1e5c95bd461"></a><!-- doxytag: member="SEND_MODE_FULL_BUFF" ref="af90bb04b825e781235018bd90980e262a80d3d8408572ff4b9b9ec1e5c95bd461" args="" -->SEND_MODE_FULL_BUFF</em>&nbsp;</td><td>
<p>Tells the send routine to send the entire buffer. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af90bb04b825e781235018bd90980e262aac81a64f198acd212a233de0916d8c7c"></a><!-- doxytag: member="SEND_MODE_ONE_PACKET" ref="af90bb04b825e781235018bd90980e262aac81a64f198acd212a233de0916d8c7c" args="" -->SEND_MODE_ONE_PACKET</em>&nbsp;</td><td>
<p>Tells the send routine to return after one packet. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3da49ce274ae8a014a14a9ef1bb2a3e7"></a><!-- doxytag: member="uhd::device::find" ref="a3da49ce274ae8a014a14a9ef1bb2a3e7" args="(const device_addr_t &amp;hint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceuhd.html#af4fc6d6f813e411184c069ba39901737">device_addrs_t</a> uhd::device::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find usrp devices attached to the host. </p>
<p>The hint device address should be used to narrow down the search to particular transport types and/or transport arguments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hint</em>&nbsp;</td><td>a partially (or fully) filled in device address </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a vector of device addresses for all usrps on the system </dd></dl>

</div>
</div>
<a class="anchor" id="ab53d8cc7dc9bc12d52bc2ab4fdf55062"></a><!-- doxytag: member="uhd::device::get_max_recv_samps_per_packet" ref="ab53d8cc7dc9bc12d52bc2ab4fdf55062" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::device::get_max_recv_samps_per_packet </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the maximum number of samples per packet on recv. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of samples </dd></dl>

</div>
</div>
<a class="anchor" id="a70d89a8eca9079a026899860d10bd9a7"></a><!-- doxytag: member="uhd::device::get_max_send_samps_per_packet" ref="a70d89a8eca9079a026899860d10bd9a7" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::device::get_max_send_samps_per_packet </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the maximum number of samples per packet on send. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of samples </dd></dl>

</div>
</div>
<a class="anchor" id="ad267bb32c7c9d7f4f24b4e29fdbcf3ec"></a><!-- doxytag: member="uhd::device::make" ref="ad267bb32c7c9d7f4f24b4e29fdbcf3ec" args="(const device_addr_t &amp;hint, size_t which=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classuhd_1_1device.html#a439ff67bbcbe999d871a179467355ed0">sptr</a> uhd::device::make </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device__addr__t.html">device_addr_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>which</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a new usrp device from the device address hint. </p>
<p>The make routine will call find and pick one of the results. By default, the first result will be used to create a new device. Use the which parameter as an index into the list of results.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hint</em>&nbsp;</td><td>a partially (or fully) filled in device address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>which</em>&nbsp;</td><td>which address to use when multiple are found </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a shared pointer to a new device instance </dd></dl>

</div>
</div>
<a class="anchor" id="a3e7e55ed84ca59310c4396a18a5e36d5"></a><!-- doxytag: member="uhd::device::recv" ref="a3e7e55ed84ca59310c4396a18a5e36d5" args="(const recv_buffs_type &amp;buffs, size_t nsamps_per_buff, rx_metadata_t &amp;metadata, const io_type_t &amp;io_type, recv_mode_t recv_mode, double timeout=0.1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::device::recv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1ref__vector.html">recv_buffs_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nsamps_per_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structuhd_1_1rx__metadata__t.html">rx_metadata_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1io__type__t.html">io_type_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuhd_1_1device.html#a3a59c1d7f04646fa7ebf7ce668362dc2">recv_mode_t</a>&nbsp;</td>
          <td class="paramname"> <em>recv_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>0.1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive buffers containing IF data described by the metadata.</p>
<p>Receive handles fragmentation as follows: If the buffer has insufficient space to hold all samples that were received in a single packet over-the-wire, then the buffer will be completely filled and the implementation will hold a pointer into the remaining portion of the packet. Subsequent calls will load from the remainder of the packet, and will flag the metadata to show that this is a fragment. The next call to receive, after the remainder becomes exahausted, will perform an over-the-wire receive as usual. See the rx metadata fragment flags and offset fields for details.</p>
<p>This is a blocking call and will not return until the number of samples returned have been written into each buffer. Under a timeout condition, the number of samples returned may be less than the number of samples specified.</p>
<p>When using the full buffer recv mode, the metadata only applies to the first packet received and written into the recv buffers. Use the one packet recv mode to get per packet metadata.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffs</em>&nbsp;</td><td>a vector of writable memory to fill with IF data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nsamps_per_buff</em>&nbsp;</td><td>the size of each buffer in number of samples </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>data to fill describing the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_type</em>&nbsp;</td><td>the type of data to fill into the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>recv_mode</em>&nbsp;</td><td>tells recv how to load the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>the timeout in seconds to wait for a packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of samples received or 0 on error </dd></dl>

</div>
</div>
<a class="anchor" id="a18f94b4369ebfa03358b06bef000dacd"></a><!-- doxytag: member="uhd::device::recv_async_msg" ref="a18f94b4369ebfa03358b06bef000dacd" args="(async_metadata_t &amp;async_metadata, double timeout=0.1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool uhd::device::recv_async_msg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structuhd_1_1async__metadata__t.html">async_metadata_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>async_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>0.1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive and asynchronous message from the device. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>async_metadata</em>&nbsp;</td><td>the metadata to be filled in </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>the timeout in seconds to wait for a message </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true when the async_metadata is valid, false for timeout </dd></dl>

</div>
</div>
<a class="anchor" id="a14097018989427c5b6e8311265a88961"></a><!-- doxytag: member="uhd::device::register_device" ref="a14097018989427c5b6e8311265a88961" args="(const find_t &amp;find, const make_t &amp;make)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void uhd::device::register_device </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device.html#a7cab70fce4219ff5910460724d09ee20">find_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>find</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1device.html#aa57d1d2a3f5774df16fbdecacbe38d5d">make_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>make</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a device into the discovery and factory system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>find</em>&nbsp;</td><td>a function that discovers devices </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>make</em>&nbsp;</td><td>a factory function that makes a device </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d302f283c89b0823c9745dc395ae679"></a><!-- doxytag: member="uhd::device::send" ref="a1d302f283c89b0823c9745dc395ae679" args="(const send_buffs_type &amp;buffs, size_t nsamps_per_buff, const tx_metadata_t &amp;metadata, const io_type_t &amp;io_type, send_mode_t send_mode, double timeout=0.1)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t uhd::device::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1ref__vector.html">send_buffs_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>buffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nsamps_per_buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structuhd_1_1tx__metadata__t.html">tx_metadata_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classuhd_1_1io__type__t.html">io_type_t</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>io_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classuhd_1_1device.html#af90bb04b825e781235018bd90980e262">send_mode_t</a>&nbsp;</td>
          <td class="paramname"> <em>send_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeout</em> = <code>0.1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send buffers containing IF data described by the metadata.</p>
<p>Send handles fragmentation as follows: If the buffer has more samples than the maximum per packet, the send method will fragment the samples across several packets. Send will respect the burst flags when fragmenting to ensure that start of burst can only be set on the first fragment and that end of burst can only be set on the final fragment. Fragmentation only applies in the full buffer send mode.</p>
<p>This is a blocking call and will not return until the number of samples returned have been read out of each buffer. Under a timeout condition, the number of samples returned may be less than the number of samples specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buffs</em>&nbsp;</td><td>a vector of read-only memory containing IF data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nsamps_per_buff</em>&nbsp;</td><td>the number of samples to send, per buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metadata</em>&nbsp;</td><td>data describing the buffer's contents </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>io_type</em>&nbsp;</td><td>the type of data loaded in the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>send_mode</em>&nbsp;</td><td>tells send how to unload the buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>the timeout in seconds to wait on a packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of samples sent </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/uhd/<a class="el" href="device_8hpp_source.html">device.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Sat Apr 2 14:36:27 2011 for UHD by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
